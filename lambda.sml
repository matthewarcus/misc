(* The obvious abstract syntax *)
type Variable = string;

datatype Exp = Var of Variable 
             | App of Exp * Exp 
             | Lambda of Variable * Exp;

(* Printing *)
fun pexp (Var x) = x
  | pexp (e as Lambda _) = "λ" ^ plambda e
  | pexp (App(e1 as App _,e2)) = pexp e1 ^ pexp1 e2
  | pexp (App(e1,e2)) = pexp1 e1 ^ pexp1 e2
and pexp1 (Var x) = x
  | pexp1 e = "(" ^ pexp e ^ ")"
and plambda(Lambda(v,e)) = v ^ plambda e
  | plambda e = "." ^ pexp e;

(* A convenience function - functionally is the identity, but also print *)
fun pp e = (print (pexp e ^ "\n"); e)

fun isfree c (Var c') = c = c'
  | isfree c (Lambda(c',e)) = if (c = c') then false else isfree c e
  | isfree c (App(e1,e2)) = if isfree c e1 then true else isfree c e2;

fun occurs c (Var c') = c = c'
  | occurs c (Lambda(c',e)) = 
    if (c = c') then true else occurs c e
  | occurs c (App(e1,e2)) = 
    if occurs c e1 then true else occurs c e2;

(* Add primes to a variable v until we find one not occurring free in e *)
fun findnew v e =
    let val v' = v ^ "'"
    in
        if not (occurs v' e) 
        then v'
        else findnew v' e
    end;

(* Substitute exp1 for var in exp2 *)
(* A rather traditional approach *)
(* de Bruijn indices or similar might be better *)
fun subst v e1 (e2 as (Var v')) = if v = v' then e1 else e2
  | subst v e1 (App(e2,e3)) = App(subst v e1 e2, subst v e1 e3)
  | subst v e1 (e2 as Lambda(v',e3)) = 
    if not (isfree v e2) then e2 (* Include case v = v' *)
    else if isfree v' e1 then 
	(* eg. "\vx.vx)x" *)
        (* find a new variable not free in e1 or e3 to use *)
        (* v'' can't be v as v is free in e2 *)
        let val v'' = findnew v' (App(e1,e3))
        in subst v e1 (Lambda(v'', subst v' (Var v'') e3))
        end
    else Lambda(v', subst v e1 e3);

(* Simple stack parser *)

(* Lexical analysis *)

(* Items generated by the lexer *)
datatype LexItem = LAM | BRA | KET | DOT | VAR of string;

(* Single letter variable names. Juxtaposition is application *)
(* Transform a character list into a LexItem list *)
(* Skip whitespace, handle utf8 lambdas etc. *)
fun lex [] t = rev t
  | lex (#"\206" :: #"\187" ::s) t = lex s (LAM::t)
  | lex (#" "::s) t = lex s t
  | lex (#"\n"::s) t = lex s t
  | lex (#"\t"::s) t = lex s t
  | lex (#"\\"::s) t = lex s (LAM::t)
  | lex (#"("::s) t = lex s (BRA::t)
  | lex (#")"::s) t = lex s (KET::t)
  | lex (#"."::s) t = lex s (DOT::t)
  | lex (c::s) t = lexvar s [c] t
and lexvar (#"'"::s) v t = lexvar s (#"'"::v) t
  | lexvar s v t = lex s (VAR (implode(rev v))::t);

(* Sort of LR stack parser *)
(* Hopefully fairly obvious how it works *)
(* Either shift or reduce depending on the parse stack and input *)
(* Parse errors result in a inexhaustive match failure *)
fun parse s = 
  let
    (* Items appearing on the parse stack *)
    datatype ParseItem = B | E of Exp | V of Variable;
    fun aux [E e] [] = e
      | aux (E e1::E e2::s) t = aux (E(App(e2,e1))::s) t
      | aux s (LAM::VAR c::DOT::t) = aux (V c::s) t
      | aux s (LAM::VAR c::VAR c'::t) = aux (V c::s) (LAM::VAR c'::t)
      | aux s (BRA::t) = aux (B::s) t
      | aux ((a as E _):: B :: s) (KET::t) = aux (a::s) t
      | aux s (VAR c::t) = aux(E(Var c)::s) t
      | aux (E e::V v::s) t = aux (E(Lambda(v,e))::s) t;
  in
      aux [] (lex (explode s) [])
  end

(* Global environment *)
fun getenv [] v = NONE
  | getenv ((v',e)::s) v =
    if (v = v') then SOME e else getenv s v;

(* We want to implement a "reduce the nth redex" function *)
(* Use option types to indicate if a subexpression has been reduced *)

(* Useful monadic operations for option type *)
fun lift f NONE = NONE
  | lift f (SOME x) = SOME (f x);

fun bind f NONE = NONE
  | bind f (SOME a) = f a;

(* Apply f to a, if no result, apply g to b *)
fun try f a g b = case f a of r as SOME _ => r | NONE => g b;

fun get (SOME x) = x;

fun reduce env n e =
  let
    fun aux n (Var _) = NONE
      | aux 0 (App(Lambda(v,e1),e2)) = SOME (subst v e2 e1)
      | aux n (App(Lambda(v,e1),e2)) =
	try (lift (fn e1' => App(Lambda(v,e1'),e2)) o aux (n-1)) e1
	    (lift (fn e2' => App(Lambda(v,e1),e2')) o aux (n-1)) e2
      | aux n (App(e1 as Var v,e2)) =
        (* This is too clever - we should only expand if a reduction is possible *)
	try (bind (fn e1' => aux n (App(e1',e2))) o getenv env) v
	    (lift (fn e2' => App(e1,e2')) o aux n) e2
      | aux n (App(e1,e2)) =
	try (lift (fn e1' => App(e1',e2)) o aux n) e1
	    (lift (fn e2' => App(e1,e2')) o aux n) e2
      | aux n (Lambda(v,e1)) =
	(lift (fn e1' => Lambda(v,e1')) o aux n) e1
  in
      aux n e
  end;

(* Normal order evaluation using an evaluation stack *)
(* Go down left branch of expression, applying reductions as we go *)
(* When have hit the bottom, recursively evaluate items on stack *)
(* Then fold back up into a single expression *)

fun eval env e = 
  let
    fun foldapp(e1::e2::s) = foldapp(App(e1,e2)::s)
      | foldapp ([e1]) = e1;
    fun aux (Lambda(v,e1)) (e2::s) = aux (subst v e2 e1) s
      | aux (Lambda(v,e1)) [] = Lambda(v, eval env e1)
      | aux (App(e1,e2)) s = aux e1 (e2::s)
      | aux (e as Var _) [] = e
      | aux (e as Var v) s = 
        (case getenv env v of
             SOME e' => aux e' s
           | _ => foldapp (map (eval env) (e::s)));
  in
    aux e []
  end;

fun mkenv [] k = k
  | mkenv (v::e::s) k = mkenv s ((v,parse e)::k)

(* And our "standard environment" *)
val stdenv = ref (
    mkenv ["S", "λxyz.(xz)(yz)",
	   "K", "λxy.x",
	   "I", "λx.x",
	   "Y", "λf.(λx.f(xx))(λx.f(xx))",
           "Y'", "λf.(λx.f(λv.((x x) v))) (λx.f (λv.((x x) v)))",
	   "M", "λxy.y(xy)",
	   "T", "λxy.x",
	   "F", "λxy.y",
	   "Z", "λn.n(λx.F)T",
	   "0", "λfn.n",
	   "N", "λnfx.f(nfx)",
	   "P", "λnfx.n(λgh.h(gf))(λu.x)(λu.u)",
	   "*", "λmnfx.m(nf)x",
	   "+", "λmnfx.mf(nfx)",
	   "1", "N0",
	   "2", "N1",
	   "3", "N2",
	   "4", "N3",
	   "5", "N4",
	   "6", "N5",
	   "7", "N6",
	   "8", "N7",
	   "9", "N8",
	   "H", "Y(λgn.(Zn)1(*n(g(Pn))))" (* Factorial function, obviously *)
	  ] []);

fun addenv n s = stdenv := (n,parse s)::(!stdenv);

(* Some convenience functions *)
(* Normal order evaluation, with printing of intermediate expressions *)
fun run n e =
  case reduce (!stdenv) n (pp e) of
    SOME e' => run n e'
  | NONE => e;

fun e s = pp (eval (!stdenv) (parse s));
fun esym s = pp (get (getenv (!stdenv) s));
fun e0 e = pp (get (reduce (!stdenv) 0 e));
fun e1 e = pp (get (reduce (!stdenv) 1 e));

(* Some test stuff *)
run 0 (parse "H2");
e "H4";
e1(e1(e0(parse"YM")));
